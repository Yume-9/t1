/*
 * TETRIS para Arduino UNO
 * Display: OLED 128x64
 * Controles: 4 botões (Girar, Direita, Descer, Esquerda)
 * 
 * Versão para iniciantes/intermediários
 * Escrito de forma simples e didática
 */

// ===== BIBLIOTECAS NECESSÁRIAS =====
#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// ===== CONFIGURAÇÃO DO DISPLAY OLED =====
#define LARGURA_TELA 128
#define ALTURA_TELA 64
#define ENDERECO_DISPLAY 0x3C  // Endereço I2C do display

// Cria o objeto do display
Adafruit_SSD1306 display(LARGURA_TELA, ALTURA_TELA, &Wire, -1);

// ===== CONFIGURAÇÃO DO JOGO =====
#define COLUNAS 10     // Largura do campo de jogo
#define LINHAS 16      // Altura do campo (4 linhas são invisíveis no topo)
#define TAMANHO_BLOCO 6  // Tamanho de cada bloco em pixels

// Posição do campo na tela
#define POS_X 2
#define POS_Y 0

// ===== PINOS DOS BOTÕES =====
#define BOTAO_GIRAR     2
#define BOTAO_DIREITA   3
#define BOTAO_DESCER    4
#define BOTAO_ESQUERDA  5

// ===== VARIÁVEIS DO JOGO =====
unsigned long ultimoMovimento = 0;      // Controle de tempo da última queda
unsigned long velocidadeQueda = 700;    // Velocidade inicial da peça (ms)
int pontuacao = 0;                      // Pontuação do jogador
int nivel = 0;                          // Nível atual
int totalLinhasCompletas = 0;           // Total de linhas completadas

// Matriz do campo de jogo: 0 = vazio, 1 = ocupado
int campo[LINHAS][COLUNAS];

// ===== FORMAS DAS PEÇAS DO TETRIS =====
// Cada peça tem 4 rotações (0°, 90°, 180°, 270°)
// Cada número hexadecimal representa os blocos de uma peça 4x4
const unsigned int formas[7][4] = {
  // Peça I (formato de bastão)
  { 0x0F00, 0x2222, 0x00F0, 0x4444 },
  // Peça O (quadrado)
  { 0x0660, 0x0660, 0x0660, 0x0660 },
  // Peça T
  { 0x0E40, 0x4C40, 0x04E0, 0x4640 },
  // Peça L
  { 0x0E10, 0x2260, 0x08E0, 0x6440 },
  // Peça J (espelho da L)
  { 0x0E80, 0x4460, 0x02E0, 0x6220 },
  // Peça S
  { 0x06C0, 0x4C80, 0x06C0, 0x4C80 },
  // Peça Z
  { 0x0C60, 0x8C40, 0x0C60, 0x8C40 }
};

// ===== PEÇA ATUAL EM JOGO =====
struct PeçaAtual {
  int x, y;           // Posição no campo
  int tipo;           // Tipo de peça (0-6)
  int rotacao;        // Rotação atual (0-3)
} peça;

// ===== FILA DE PRÓXIMAS PEÇAS =====
int proximas[3];      // Próximas 3 peças que virão
int saco[7];          // Saco com todas as 7 peças
int indiceSaco = 7;   // Índice atual no saco

// ===== FUNÇÕES DO JOGO =====

// Obtém a forma de uma peça específica
unsigned int obterForma(int tipo, int rotacao) {
  return formas[tipo][rotacao % 4];
}

// Embaralha as peças no saco (garante que todas apareçam antes de repetir)
void embaralharSaco() {
  // Preenche o saco com todas as peças (0 a 6)
  for (int i = 0; i < 7; i++) {
    saco[i] = i;
  }
  
  // Embaralha as peças (algoritmo simples)
  for (int i = 0; i < 7; i++) {
    int posicaoAleatoria = random(0, 7);
    int temp = saco[i];
    saco[i] = saco[posicaoAleatoria];
    saco[posicaoAleatoria] = temp;
  }
  
  indiceSaco = 0;
}

// Pega a próxima peça do saco
int pegarProximaPeça() {
  if (indiceSaco >= 7) {
    embaralharSaco();
  }
  return saco[indiceSaco++];
}

// Cria uma nova peça no topo do campo
void novaPeça() {
  peça.tipo = proximas[0];
  peça.rotacao = 0;
  peça.x = 3;      // Posição central
  peça.y = -1;     // Começa acima do campo (invisível)
  
  // Atualiza a fila de próximas peças
  proximas[0] = proximas[1];
  proximas[1] = proximas[2];
  proximas[2] = pegarProximaPeça();
}

// Verifica se a peça pode se mover para uma posição
bool podeMover(int novoX, int novoY, int tipo, int rotacao) {
  unsigned int forma = obterForma(tipo, rotacao);
  
  // Verifica cada bloco da peça 4x4
  for (int linha = 0; linha < 4; linha++) {
    for (int coluna = 0; coluna < 4; coluna++) {
      // Verifica se este bloco está preenchido na peça
      if (forma & (1 << (15 - (linha * 4 + coluna)))) {
        int posX = novoX + coluna;
        int posY = novoY + linha;
        
        // Verifica se está fora dos limites ou colidindo com outro bloco
        if (posX < 0 || posX >= COLUNAS || posY >= LINHAS || 
            (posY >= 0 && campo[posY][posX] == 1)) {
          return false;
        }
      }
    }
  }
  
  return true;
}

// Fixa a peça atual no campo
void fixarPeça() {
  unsigned int forma = obterForma(peça.tipo, peça.rotacao);
  
  // Marca os blocos ocupados pela peça
  for (int linha = 0; linha < 4; linha++) {
    for (int coluna = 0; coluna < 4; coluna++) {
      if (forma & (1 << (15 - (linha * 4 + coluna)))) {
        int posX = peça.x + coluna;
        int posY = peça.y + linha;
        
        if (posY >= 0 && posY < LINHAS && posX >= 0 && posX < COLUNAS) {
          campo[posY][posX] = 1;
        }
      }
    }
  }
  
  // Verifica se há linhas completas
  verificarLinhas();
  
  // Cria uma nova peça
  novaPeça();
}

// Verifica e remove linhas completas
void verificarLinhas() {
  int linhasRemovidas = 0;
  
  // Verifica cada linha de baixo para cima
  for (int linha = LINHAS - 1; linha >= 0; linha--) {
    bool linhaCompleta = true;
    
    // Verifica se todos os blocos da linha estão preenchidos
    for (int coluna = 0; coluna < COLUNAS; coluna++) {
      if (campo[linha][coluna] == 0) {
        linhaCompleta = false;
        break;
      }
    }
    
    // Se a linha está completa, remove e desce as de cima
    if (linhaCompleta) {
      for (int l = linha; l > 0; l--) {
        for (int c = 0; c < COLUNAS; c++) {
          campo[l][c] = campo[l - 1][c];
        }
      }
      
      // Limpa a linha do topo
      for (int c = 0; c < COLUNAS; c++) {
        campo[0][c] = 0;
      }
      
      linha++; // Verifica a mesma posição novamente
      linhasRemovidas++;
    }
  }
  
  // Atualiza pontuação se linhas foram removidas
  if (linhasRemovidas > 0) {
    // Sistema de pontuação clássico do Tetris
    if (linhasRemovidas == 1) {
      pontuacao += 40 * (nivel + 1);
    } else if (linhasRemovidas == 2) {
      pontuacao += 100 * (nivel + 1);
    } else if (linhasRemovidas == 3) {
      pontuacao += 300 * (nivel + 1);
    } else if (linhasRemovidas == 4) {
      pontuacao += 1200 * (nivel + 1);
    }
    
    totalLinhasCompletas += linhasRemovidas;
    
    // Aumenta o nível a cada 10 linhas
    int novoNivel = totalLinhasCompletas / 10;
    if (novoNivel > nivel) {
      nivel = novoNivel;
      // Aumenta a velocidade (diminui o tempo entre quedas)
      if (velocidadeQueda > 100) {
        velocidadeQueda = velocidadeQueda - 60;
      }
    }
  }
}

// ===== FUNÇÕES DE VISUALIZAÇÃO =====

// Desenha um bloco na posição especificada
void desenharBloco(int linha, int coluna) {
  display.fillRect(
    POS_X + coluna * TAMANHO_BLOCO, 
    POS_Y + linha * TAMANHO_BLOCO, 
    TAMANHO_BLOCO - 1, 
    TAMANHO_BLOCO - 1, 
    SSD1306_WHITE
  );
}

// Desenha uma peça em miniatura (para a área de próximas peças)
void desenharMiniatura(int x, int y, int tipo, int rotacao) {
  unsigned int forma = obterForma(tipo, rotacao);
  int larguraMini = 3;
  int alturaMini = 2;
  
  for (int linha = 0; linha < 4; linha++) {
    for (int coluna = 0; coluna < 4; coluna++) {
      if (forma & (1 << (15 - (linha * 4 + coluna)))) {
        display.fillRect(
          x + coluna * larguraMini, 
          y + linha * alturaMini, 
          larguraMini - 1, 
          alturaMini - 1, 
          SSD1306_WHITE
        );
      }
    }
  }
}

// Desenha toda a cena do jogo
void desenharTudo() {
  display.clearDisplay();
  
  // Desenha os blocos fixos do campo
  for (int linha = 0; linha < LINHAS; linha++) {
    for (int coluna = 0; coluna < COLUNAS; coluna++) {
      if (campo[linha][coluna] == 1) {
        desenharBloco(linha, coluna);
      }
    }
  }
  
  // Desenha a peça atual
  unsigned int forma = obterForma(peça.tipo, peça.rotacao);
  for (int linha = 0; linha < 4; linha++) {
    for (int coluna = 0; coluna < 4; coluna++) {
      if (forma & (1 << (15 - (linha * 4 + coluna)))) {
        int posX = peça.x + coluna;
        int posY = peça.y + linha;
        
        if (posY >= 0 && posX >= 0 && posX < COLUNAS && posY < LINHAS) {
          desenharBloco(posY, posX);
        }
      }
    }
  }
  
  // Desenha a borda do campo
  display.drawRect(
    POS_X - 1, 
    POS_Y - 1, 
    COLUNAS * TAMANHO_BLOCO + 1, 
    LINHAS * TAMANHO_BLOCO + 1, 
    SSD1306_WHITE
  );
  
  // ===== PAINEL DE INFORMAÇÕES =====
  int painelX = POS_X + COLUNAS * TAMANHO_BLOCO + 6;
  int y = 0;
  
  // Título "Próximas"
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(painelX, y);
  display.print(F("PROXIMAS"));
  
  // Desenha as próximas 3 peças
  for (int i = 0; i < 3; i++) {
    desenharMiniatura(painelX, y + 10 + i * 12, proximas[i], 0);
  }
  
  // Pontuação
  y = y + 10 + 3 * 12 + 4;
  display.setCursor(painelX, y);
  display.print(F("PONTOS"));
  y = y + 8;
  display.setCursor(painelX, y);
  display.print(pontuacao);
  
  // Nível
  y = y + 10;
  display.setCursor(painelX, y);
  display.print(F("NIVEL "));
  display.print(nivel);
  
  // Atualiza a tela
  display.display();
}

// ===== CONFIGURAÇÃO INICIAL =====
void setup() {
  Serial.begin(115200);
  
  // Inicializa o display OLED
  if (!display.begin(SSD1306_SWITCHCAPVCC, ENDERECO_DISPLAY)) {
    Serial.println(F("Erro: Display OLED não encontrado!"));
    while (true); // Para o programa se o display não funcionar
  }
  
  // Configura os botões como entrada com resistor de pull-up
  pinMode(BOTAO_GIRAR, INPUT_PULLUP);
  pinMode(BOTAO_DIREITA, INPUT_PULLUP);
  pinMode(BOTAO_DESCER, INPUT_PULLUP);
  pinMode(BOTAO_ESQUERDA, INPUT_PULLUP);
  
  // Inicializa o gerador de números aleatórios
  randomSeed(analogRead(A5));
  
  // Limpa o campo de jogo
  for (int linha = 0; linha < LINHAS; linha++) {
    for (int coluna = 0; coluna < COLUNAS; coluna++) {
      campo[linha][coluna] = 0;
    }
  }
  
  // Prepara o sistema de peças
  embaralharSaco();
  for (int i = 0; i < 3; i++) {
    proximas[i] = pegarProximaPeça();
  }
  
  // Cria a primeira peça
  novaPeça();
  
  // Desenha a tela inicial
  desenharTudo();
}

// ===== LOOP PRINCIPAL =====
void loop() {
  unsigned long tempoAtual = millis();
  
  // Lê o estado dos botões (LOW quando pressionado)
  bool botaoGirar = !digitalRead(BOTAO_GIRAR);
  bool botaoDireita = !digitalRead(BOTAO_DIREITA);
  bool botaoDescer = !digitalRead(BOTAO_DESCER);
  bool botaoEsquerda = !digitalRead(BOTAO_ESQUERDA);
  
  // Variáveis para controlar a repetição de botões
  static unsigned long ultimoEsquerda = 0;
  static unsigned long ultimoDireita = 0;
  static unsigned long ultimoDescer = 0;
  static bool ultimoGirar = false;
  
  // ===== CONTROLES =====
  
  // Movimento para esquerda
  if (botaoEsquerda && tempoAtual - ultimoEsquerda > 120) {
    if (podeMover(peça.x - 1, peça.y, peça.tipo, peça.rotacao)) {
      peça.x = peça.x - 1;
    }
    ultimoEsquerda = tempoAtual;
  }
  
  // Movimento para direita
  if (botaoDireita && tempoAtual - ultimoDireita > 120) {
    if (podeMover(peça.x + 1, peça.y, peça.tipo, peça.rotacao)) {
      peça.x = peça.x + 1;
    }
    ultimoDireita = tempoAtual;
  }
  
  // Descida rápida (soft drop)
  if (botaoDescer && tempoAtual - ultimoDescer > 120) {
    if (podeMover(peça.x, peça.y + 1, peça.tipo, peça.rotacao)) {
      peça.y = peça.y + 1;
      pontuacao = pontuacao + 1; // Pontuação extra por descida rápida
    }
    ultimoDescer = tempoAtual;
  }
  
  // Rotação da peça
  if (botaoGirar && !ultimoGirar) {
    int novaRotacao = (peça.rotacao + 1) % 4;
    
    // Tenta rotacionar, com ajustes laterais se necessário
    if (podeMover(peça.x, peça.y, peça.tipo, novaRotacao)) {
      peça.rotacao = novaRotacao;
    } else if (podeMover(peça.x + 1, peça.y, peça.tipo, novaRotacao)) {
      peça.x = peça.x + 1;
      peça.rotacao = novaRotacao;
    } else if (podeMover(peça.x - 1, peça.y, peça.tipo, novaRotacao)) {
      peça.x = peça.x - 1;
      peça.rotacao = novaRotacao;
    }
  }
  ultimoGirar = botaoGirar;
  
  // ===== QUEDA AUTOMÁTICA =====
  if (tempoAtual - ultimoMovimento >= velocidadeQueda) {
    ultimoMovimento = tempoAtual;
    
    // Tenta mover a peça para baixo
    if (podeMover(peça.x, peça.y + 1, peça.tipo, peça.rotacao)) {
      peça.y = peça.y + 1;
    } else {
      // Se não pode descer, verifica se é game over
      if (peça.y < 0) {
        // Game over - reinicia o jogo
        for (int linha = 0; linha < LINHAS; linha++) {
          for (int coluna = 0; coluna < COLUNAS; coluna++) {
            campo[linha][coluna] = 0;
          }
        }
        pontuacao = 0;
        nivel = 0;
        totalLinhasCompletas = 0;
        velocidadeQueda = 700;
        
        embaralharSaco();
        for (int i = 0; i < 3; i++) {
          proximas[i] = pegarProximaPeça();
        }
        novaPeça();
      } else {
        // Fixa a peça no campo e cria uma nova
        fixarPeça();
      }
    }
  }
  
  // Atualiza a tela
  desenharTudo();
}
